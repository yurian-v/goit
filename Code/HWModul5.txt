HW5
________________
1.
Путешествуя по Галактике, ты добрался до укромного уголка 
вселенной - планеты Санрайз.

Молодая и амбициозная компания It Software собирается создать 
игру невиданного ранее жанра - побегухи-пострелухи. 
Игру хотят назвать Quarke.

Основатель компании, Джон Карм, просит тебя помочь в реализации 
некоторых алгоритмов. Игру пытались написать на языке C, 
но запутались в указателях и прямой работе с памятью, и перешли 
на Java. А поскольку ты признанный специалист по этому языку, 
и к тому же оказался на планете Санрайз - обратились к тебе.


Задание

Напиши класс для описания главного героя игры - Hero. У этого 
класса должны быть два поля:

    поле name строкового типа. В этом поле будет храниться имя 
главного героя;
    поле hp типа int. Здесь будет храниться количество оставшихся 
очков здоровья.

В классе Hero также допиши конструктор без параметров, который 
будет инициализировать поле name значением "Paratrooper", 
а поле hp - значением 100.

Для полей name и hp напиши геттеры, сеттеры писать необязательно.
_________________________________________________________________

class HeroTest {
    public static void main(String[] args) {
        Hero hero = new Hero();

        //Expect Paratrooper
        System.out.println(hero.getName());

        //Expect 100
        System.out.println(hero.getHp());
    }
}
class Hero{
    private String name;
    private int hp;
  
    public Hero() {
        this.name = "Paratrooper";
        this.hp = 100;
    }

    public String getName() {
        return name;
    }

    public int getHp() {
        return hp;
    }
}
__________________________________________________________________
2.
Допиши в классе Hero конструктор, который принимает два 
параметра - имя главного героя, и число его жизней. 
Задай полям name и hp значения этих параметров.

Не удаляй конструктор по умолчанию, он должен работать так же, 
как и работал раньше.
__________________________________________________________________
class Hero {
    private String name;
    private int hp;

    public Hero() {
        name = "Paratrooper";
        hp = 100;
    }
  
  public Hero(String name, int hp) {
        this.name = name;
        this.hp = hp;
    }

    public String getName() {
        return name;
    }

    public int getHp() {
        return hp;
    }
}

class HeroTest {
    public static void main(String[] args) {
        Hero hero = new Hero("Stranger", 50);

        //Expect Stranger
        System.out.println(hero.getName());

        //Expect 50
        System.out.println(hero.getHp());
    }
}
__________________________________________________________________
3.
Сделай рефакторинг кода. Перепиши конструктор Hero() без
 параметров так, чтобы он вызывал конструктор 
Hero(String, int) с параметрами, используя ключевое 
слово this.

В остальном поведение программы не должно измениться.
__________________________________________________________________
class HeroTest {
    public static void main(String[] args) {
        Hero hero = new Hero();

        //Expect Paratrooper
        System.out.println(hero.getName());

        //Expect 100
        System.out.println(hero.getHp());
    }
}
class Hero {
    private String name;
    private int hp;

    public Hero() {
        this("Paratrooper", 100);
    }

    public Hero(String name, int hp) {
        this.name = name;
        this.hp = hp;
    }

    public String getName() {
        return name;
    }

    public int getHp() {
        return hp;
    }
}
__________________________________________________________________
4.
Теперь класс Hero написан хорошо и красиво, с применением 
правильных техник.

Но сейчас мы можем передавать в конструктор любые значения 
жизни - hp. Это не совсем правильно, у героя не может быть 
меньше 0 и больше 200 очков жизней.

Чтобы предовратить это, нужно сделать валидацию данных в 
конструкторе.

Задание

Допиши конструктор Hero(String, int) так, чтобы он ограничивал 
значение поля hp диапазоном от 0 до 200 включительно.
__________________________________________________________________
class Hero {
    private String name;
    private int hp;

   public Hero(String name, int hp) {
        if (hp < 0){
            this.hp = 0;
        } else if (hp > 200) {
            this.hp = 200;
        } else {
            this.hp = hp;;
        }
        this.name = name;
    }

    public Hero() {
        this("Paratrooper", 100);
    }

    public String getName() {
        return name;
    }

    public int getHp() {
        return hp;
    }
}

class HeroTest {
    public static void main(String[] args) {
        Hero hero = new Hero("Stranger", 50);

        //Expect Stranger
        System.out.println(hero.getName());

        //Expect 50
        System.out.println(hero.getHp());
    }
}
__________________________________________________________________

5. 
Создай класс BFG, у которого будет три поля:

    int ammo - здесь хранятся патроны, по умолчанию 1000;
    int damage - здесь хранится наносимый оружием урон, по 
умолчанию 50;
    String name - здесь хранится имя оружия, по умолчанию BFG.

Создай геттеры для каждого поля.

У класса должно быть 4 конструктора:

    BFG(int ammo, int damage, String name) - задаем значения 
всем параметрам;
    BFG(int ammo, int damage) - задаем значения лишь двух 
параметров, количества патронов и урон, поле name инициализируется
 значением по умолчанию;
    BFG(int ammo) - задаем значение лишь количества патронов, 
урон и имя инициализируется по умолчанию;
    BFG() - конструктор без параметров, здесь полям ammo, damage 
и name задаются значения по умолчанию.

Также переопредели метод toString(), чтобы он возвращал для 
класса BFG строку в формате <NAME>, ammo: <AMMO>, damage: 
<DAMAGE>. Вместо <NAME>, <AMMO>, <DAMAGE> подставляются 
значения полей name, value и damage.
__________________________________________________________________

class BfgTest {
    public static void main(String[] args) {
        //ExtraGun, ammo: 10000, damage: 300
        System.out.println(new BFG(10000, 300, "ExtraGun"));

        //BFG, ammo: 5000, damage: 200
        System.out.println(new BFG(5000, 200));

        //BFG, ammo: 2000, damage: 50
        System.out.println(new BFG(2000));

        //BFG, ammo: 1000, damage: 50
        System.out.println(new BFG());

    }
}
class BFG{
    private int ammo;
    private  int damage;
    private String name;

    public int getAmmo() {
        return ammo;
    }

    public int getDamage() {
        return damage;
    }

    public String getName() {
        return name;
    }

public BFG() {
        this (1000, 50, "BFG");
    }
    public BFG(int ammo) {
        this(ammo, 50,"BFG");
    }public BFG(int ammo, int damage) {
        this(ammo, damage, "BFG");
    }
    public BFG(int ammo, int damage, String name) {
        this.ammo = ammo;
        this.damage = damage;
        this.name = name;
    }

    @Override
    public String toString() {
        return name + ", ammo: " + ammo + ", damage: " + damage;
    }
}
__________________________________________________________________
6.
В коде уже есть описанный класс Bullet. Допиши в этот класс блок 
инициализации, чтобы при каждом создании объекта типа Bullet в 
консоль выводился бы текст Bullet created!. Не создавай ни одного 
конструктора в классе Bullet.
__________________________________________________________________
class Bullet {
    {
        System.out.println("Bullet created!");
    }
    
class BulletTest {
    {
        System.out.println("Bullet created!");
    }
}
    public static void main(String[] args) {
        new Bullet();
        new Bullet();
    }
}
__________________________________________________________________
7.
Допиши в классе GameSaver статический блок инициализации, 
чтобы при создании первого объекта GameSaver в консоль выводился 
текст GameSaver created!.
__________________________________________________________________
class GameSaver {
  static {
        System.out.println("GameSaver created!");
    } 
}

class GameSaverTest {
    public static void main(String[] args) {
        //GameSaver created!
        for(int i = 0; i < 10; i++) {
            new GameSaver();
        }
    }
}
__________________________________________________________________
8.
Напиши статический блок инициализации, где массив POWER_2 
инициализируется квадратами чисел от 1 до 10 включительно. 
Используй именно статический блок инициализации, не обычный.
__________________________________________________________________

import java.util.Arrays;

class PowTable {
public static final int[] POWERS_2 = {1, 4, 9, 16, 25, 36, 49, 64, 81, 100};
static {
        int[] POWERS_2 = {1, 4, 9, 16, 25, 36, 49, 64, 81, 100};
    }
    
}

class PowTableTest {
    public static void main(String[] args) {
        //[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
        System.out.println(Arrays.toString(PowTable.POWERS_2));
    }
}
__________________________________________________________________
9.
Напиши класс AI, который бы:

    при создании первого объекта выводил бы в консоль 
текст AI loaded!;
    при создании каждого объекта выводил бы в консоль 
текст New AI created!.

В классе AI не должно быть ни одного конструктора.
__________________________________________________________________
class AITest {
    public static void main(String[] args) {
        for(int i = 0; i < 3; i++) {
            new AI();
        }
    }
}
class AI{
    static {
        System.out.println("AI loaded!");
    }
    {
        System.out.println("New AI created!");
    }
}
__________________________________________________________________
10.
Напиши класс Distance, у которого есть конструктор 
Distance(int startX, int startY, int endX, int endY). 
Этот конструктор принимает 4 параметра - координаты 
начальной точки (startX и startY), и координаты конечной 
точки (endX и endY).

У класса также должен быть метод public int getDistance(). 
Он возвращает расстояние между точками, координаты которых 
переданы в конструктор. Расстояние округляется по правилам 
математического округления, возвращается целый результат.
__________________________________________________________________
import java.util.*;
class DistanceTest {
    public static void main(String[] args) {
        //Expect 14
        System.out.println(new Distance(10, 10, 20, 20).getDistance());

        //Expect 23
        System.out.println(new Distance(10, 10, 27, 25).getDistance());
    }
}

class Distance {
        private int startX;
        private int endX;
        private int endY;
        private int startY;

        public Distance(int startX, int startY, int endX, int endY) {
                this.startX = startX;
                this.startY = startY;
                this.endX = endX;
                this.endY = endY;
        }
        public int getDistance() {
                double d = Math.round(Math.sqrt(((startX - endX) * (startX - endX)) + ((endY - startY) * (endY - startY))));
                return (int) d;
        }
}
__________________________________________________________________
11.
Напиши класс RectangleArea, у которого есть конструктор 
public RectangleArea(int[] coords). Первые два элемента - 
это x и y первой точки прямоугольника, последние два элемента - 
это x и y противоположной точки.

У этого класса есть метод public int getArea(), который 
возвращает площадь прямоугольника.
__________________________________________________________________

class RectangleAreaTest {
    public static void main(String[] args) {
        int[] coords = {2, 2, 12, 12};

        //Expect 100
        System.out.println(new RectangleArea(coords).getArea());
    }
}
class RectangleArea{
    private int[] coords;

    public RectangleArea(int[] coords){
        this.coords = coords;

    }

    public int getArea() {
        return (Math.abs((coords[2] - coords[0])*(coords[3] - coords[1])));
    }
}
__________________________________________________________________
12.
Напиши класс CircleIntersector. Создай у этого класса конструктор 
public CircleIntersector(int x1, int y1, int r1, int x2, int y2, 
int r2).

Параметры x1, y1, r1 - это координаты первого круга. Параметры 
x2, y2, r2 - это координаты второго круга.

Переопредели метод toString() так, чтобы он возвращал intersects, 
если круги пересекаются, и not intersects, если не пересекаются.
__________________________________________________________________
class CircleIntersectorTest {
    public static void main(String[] args) {
        //intersects
        System.out.println(new CircleIntersector(0, 0, 2, 4, 0, 2));

        //not intersects
        System.out.println(new CircleIntersector(0, 0, 1, 4, 0, 2));

        //not intersects
        System.out.println(new CircleIntersector(5, 5, 2, 8, 8, 2));
    }
}
class CircleIntersector{
    private int x1;
    private int x2;
    private int y2;
    private int y1;
    private int r1;
    private int r2;

    @Override
    public String toString() {
        double someV = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        if (someV > r1 + r2){
            return "not intersects";
        }
        return "intersects";
    }

    public CircleIntersector(int x1, int y1, int r1, int x2, int y2, int r2){
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
        this.r1 = r1;
        this.r2 = r2;
    }
}
__________________________________________________________________
13.
Напиши класс QuarkeTrack, у которого есть конструктор public 
QuarkeTrack(int[] lines). Это конструктор принимает массив из 
целых чисел. Каждое целое число - это длина пробежки игрока. 
Пробежка игрока за раунд - это сумма всех отдельных пробежек.

Переопредели метод equals(), чтобы объекты QuarkeTrack с 
одинаковой длиной пробежки игрока за раунда возвращали true 
при сравнении их методом equals().

Также переопредели метод hashCode(). Можешь использовать 
Objects.hash() (тогда не забудь импортировать этот класс из 
пакета java.util). Необязательно использовать именно этот метод, 
но он весьма удобен.
__________________________________________________________________
import java.util.*;
class QuarkeTrack{
    private int tracsTogether = 0;
    public QuarkeTrack(int[] lines){
        for (int i = 0; i<lines.length; i++){
            tracsTogether += lines[i];
        }
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        QuarkeTrack quarkeTrack = (QuarkeTrack) o;
        return this.tracsTogether == quarkeTrack.tracsTogether;
    }
    @Override
    public int hashCode() {
        return Objects.hash(tracsTogether);
    }
}
class QuarkeTrackTest {
    public static void main(String[] args) {
        int[] track1Data = {1, 3, 5};
        int[] track2Data = {3, 5, 4};
        int[] track3Data = {1, 5, 3};

        QuarkeTrack track1 = new QuarkeTrack(track1Data);
        QuarkeTrack track2 = new QuarkeTrack(track2Data);
        QuarkeTrack track3 = new QuarkeTrack(track3Data);

        //false
        System.out.println(track1.equals(track2));

        //true
        System.out.println(track1.equals(track3));

        //Can be true or false
        System.out.println(track1.hashCode() == track2.hashCode());

        //true
        System.out.println(track1.hashCode() == track3.hashCode());
    }
}
__________________________________________________________________
14.
Напиши класс Rectangle, у которого есть конструктор public 
Rectangle(int a, int b). Он принимает два параметра - стороны 
прямоугольника.

Напиши метод public boolean canPlaceInto(Rectangle anotherRect). 
Он принимает другой прямоугольник, и возвращает true, если 
текущий прямоугольник можно вписать в прямоугольник anotherRect, 
и false в противном случае.
__________________________________________________________________
class RectangleTest {
    public static void main(String[] args) {
        Rectangle r1 = new Rectangle(10, 5);
        Rectangle r2 = new Rectangle(3, 7);
        Rectangle r3 = new Rectangle(10, 15);

        //false
        System.out.println(r1.canPlaceInto(r2));

        //true
        System.out.println(r1.canPlaceInto(r3));

        //true
        System.out.println(r2.canPlaceInto(r3));

        //false
        System.out.println(r3.canPlaceInto(r2));
    }
}
class Rectangle{

    private int a;
    private int b;

    public int getA() {
        return a;
    }

    public int getB() {
        return b;
    }

    public Rectangle(int a, int b){
        this.a = a;
        this.b = b;
    }

    public boolean canPlaceInto(Rectangle anotherRect) {
         if ((anotherRect.a >= a && anotherRect.b >= b) || anotherRect.a > a && b >= 
((2 * anotherRect.a * anotherRect.b * a + (anotherRect.a * anotherRect.a - 
anotherRect.b * anotherRect.b) * Math.sqrt
(anotherRect.a * anotherRect.a + anotherRect.b * anotherRect.b - a * a))) /
 (anotherRect.a * anotherRect.a + anotherRect.b * anotherRect.b))

         {
          return true;
        }
        return false;
    }
}
__________________________________________________________________

15. Напиши класс TargetFinder. Этот класс имеет метод 
public int[] findTarget(int[] aiCoords, int[][] targets). 
Этот метод принимает два параметра:

    aiCoords - координаты точки, где сейчас находится ИИ. 
Это массив из двух элементов, x и y соответственно;
    targets - двумерный массив. Каждый элемент массива - 
это массив из двух элементов, x и y потенциальной цели 
соответственно.

Метод возвращает точку ближайшей цели из массива targets. 
Это массив из двух точек - x и y соответственно.
__________________________________________________________________